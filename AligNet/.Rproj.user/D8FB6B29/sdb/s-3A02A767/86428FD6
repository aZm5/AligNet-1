{
    "contents" : "---\ntitle: \"Global alignment dme vs sce\"\nauthor: \"Adrià Alcalá Mena\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Vignette Title}\n  %\\VignetteEngine{knitr::rmarkdown}\n  \\usepackage[utf8]{inputenc}\n---\n\nGlobal alignment from Drosophila Melanogaster to Saccharomyces cerevisiae\n=========================================================================\n\n```{r ,echo=FALSE, results='hide'}\nlibrary(knitr)\n\n```\n\n```{r ,warning=FALSE}\nlibrary(AligNet)\n```\n\n\n\nFirst we have to load the data and build the networks. We can build them using the function *read.network*. For example, from a list of protein interactions.\n\n\n```{r networks}\nt1 = proc.time()\ndata(sce2)\ndata(dme2)\nnet1 = simplify(read.network(dme2,mode=\"edges\"))\nnet2 = simplify(read.network(sce2,mode=\"edges\"))\nt2 = proc.time()\n\n```\n\nNow we need a similarity matrix, you can use the function *read.matrix* if you want to read the matrix from a file, or \nyou can compute it using the function *compute.matrix*. In \nthis case we compute a distance similarity matrix, with the function *compute.matrix*.\n\n```{r matrices}\nt3 = proc.time()\n#data(sceBlast2)\n#data(dmeBlast2)\n#data(dmesceBlast2)\n\ndis1 = compute.matrix(net1)\ndis2 = compute.matrix(net2)\nsim = compute.matrix.Degree(net1,net2)\ndimnames(sim)=list(V(net1)$name,V(net2)$name)\nt4 = proc.time()\n```\n\n\n\nWhen we have the networks and the similarity matrices, we can compute the clusters with the functions *cluster.network* and *extract.clusters*, and then visualize the clusters with *display.clusters*.\n\n```{r clusters}\nt7 = proc.time()\nq31 = fivenum(dis1)[3]\nclust1 = cluster.network(dis1,q31,20)\nclusters1 = extract.clusters(net1,clust1)\nnames(clusters1)=V(net1)$name\n\nq32 = fivenum(dis2)[3]\nclust2 = cluster.network(dis2,q32,20)\nclusters2 = extract.clusters(net2,clust2)\nnames(clusters2)=V(net2)$name\nt8 = proc.time()\n```\n\n```{r visualizeall}\nt9 = proc.time()\ndisplay.clusters(clust1,net1)\nt10=proc.time()\n```\n\n\n```{r visualizezoom}\nt11=proc.time()\ndisplay.clusters(clust1,net1,zoom=100,type=0)\ndisplay.clusters(clust1,net1,zoom=100,type=1)\ndisplay.clusters(clust1,net1,zoom=100,type=2)\ndisplay.clusters(clust1,net1,zoom=100,type=3)\nt12 = proc.time()\n```\n\n```{r visualizeall2}\nt13 = proc.time()\ndisplay.clusters(clust2,net2)\nt14 = proc.time()\n```\n\n```{r visualizezoom2}\nt15 = proc.time()\ndisplay.clusters(clust2,net2,zoom=100,type=0)\ndisplay.clusters(clust2,net2,zoom=100,type=1)\ndisplay.clusters(clust2,net2,zoom=100,type=2)\ndisplay.clusters(clust2,net2,zoom=100,type=3)\nt16 = proc.time()\n\n```\n\n\nOnce we have the clusters, we can compute the local alignments using *align.local.all*. We use a dissimilarity matrices to compute the local alignments.\n\n```{r localalign}\nt17=proc.time()\nlocalAligns = align.local.all(clusters1,clusters2,sim,20,cores=4)\nt18=proc.time()\n````\n\nFinally, using the local alignments, we can compute the global alignment, using *align.global*.\n\n```{r globalalign}\nt19=proc.time()\nglobal = align.global(localAligns,sim)\nt20=proc.time()\n```\n\nTo compute the edge correctness score of the global alignment, we use the function *EC.score*.\n\n```{r ECscore}\nt21 = proc.time()\n\nprint(EC.score(global[[2]],net1,net2))\nt22=proc.time()\n```\n\n\nTo compute the functional coherence score of the global alignment, first we need to load de data *gos2* and then we use the function *FC.score*.\n\n```{r FCscore}\nt23 = proc.time()\ndata(gos2)\n\n\nprint(FC.score(global[[2]],gos2))\nt24 = proc.time()\n```\n\nTo visualize the global alignment, we can plot all the alignment with *align.plot*, or visualize only one local alignment using *align.local.plot*. The first one is useful when we have small networks, and the second one for large networks.\n\n```{r plotglobal}\nt25 = proc.time()\nalign.plot(net1,net2,global[[2]],1,1,edge.curved=0.5,vertex.size=1,vertex.label=\"\")\n\nt26 = proc.time()\n```\n\n\n\n```{r plotlocal1}\nt27 = proc.time()\nalign.local.plot(localAligns,global[[2]],\"dm8134\",\"sc1849\",net1,net2,vertex.size=5)\nt28 = proc.time()\n```\n\n```{r plotlocal2}\nt29 = proc.time()\nalign.local.plot(localAligns,global[[2]],\"dm11311\",\"sc3848\",net1,net2,vertex.size=5)\nt30 = proc.time()\n```\n\n\n```{r plotlocal3}\nt31=proc.time()\nalign.local.plot(localAligns,global[[2]],\"dm3973\",\"sc90\",net1,net2,vertex.label=\"\",vertex.size=5)\nt32 = proc.time()\n```\n\n```{r temps, echo=FALSE}\nread.networks = t2[3]-t1[3]\ncompute.matrices = t4[3]-t3[3]\ncompute.clusters = t8[3]-t7[3]\nvisualize.clusters.all = t10[3]-t9[3]\nvisualize.clusters.zoom = t12[3]-t11[3]\nvisualize.clusters.all2 = t14[3]-t13[3]\nvisualize.clusters.zoom2 = t16[3]-t15[3]\ncompute.local.align = t18[3]-t17[3]\ncompute.global.align = t20[3]-t19[3]\ncompute.ec.score = t22[3]-t21[3]\ncompute.fc.score = t24[3]-t23[3]\nplot.all = t26[3]-t25[3]\nplot.locals = t32[3]-t27[3]\n\ntimes = c(read.networks,compute.matrices, \n          compute.clusters, visualize.clusters.all ,\n          visualize.clusters.zoom,\n          visualize.clusters.all2,\n          visualize.clusters.zoom2,compute.local.align,\n          compute.global.align,compute.ec.score,\n          compute.fc.score,plot.all,plot.locals)\ntimes.names = c(\"read.networks\",\"compute.matrices\",\n                \"compute.clusters\", \n                \"visualize.clusters.all\" ,\n                \"visualize.clusters.zoom\",\n                \"visualize.clusters.all2\",\n                \"visualize.clusters.zoom2\",\n                \"compute.local.align\",\n                \"compute.global.align\",\"compute.ec.score\",\n                \"compute.fc.score\",\"plot.all\",\"plot.locals\")\ntimes.table = cbind(times.names,times)\n\nprepare.data = sum(times[1:2])\ncompute.clusters = times[3]\ncompute.local = times[8]\ncompute.global = times[9]\ncompute.all = times[3]+times[8]+times[9]\ncompute.times = c(prepare.data,compute.clusters,\n                  compute.local,compute.global,compute.all)\ncompute.times.names = c(\"prepare.data\",\"compute.clusters\",\n                  \"compute.local\",\"compute.global\",\n                  \"compute.all\")\ncompute.times.table = cbind(compute.times.names,compute.times)\n```\n\n```{r tempstable}\ntimes.table\n\ncompute.times.table\n\n```\n\n",
    "created" : 1447581278554.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3112755210",
    "id" : "86428FD6",
    "lastKnownWriteTime" : 1447620163,
    "path" : "~/PaquetPintas/AligNet/vignettes/dme.sce.Rmd",
    "project_path" : "vignettes/dme.sce.Rmd",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "r_markdown"
}
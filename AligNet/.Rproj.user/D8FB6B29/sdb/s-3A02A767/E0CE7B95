{
    "contents" : "\n#'Read Matrix\n#'\n#'Read a matrix in several formats\n#'@param fileName directory of the matrix or data.frame (for mode col3)\n#'@param mode table, col3, RData\n#'@param sym True if the matrix must be symmetric.In modes table and RData,\n#'if the matrix is not symmetric the value of M[i,j] will be (M[i,j]+M[j,i])/2.\n#'In mode in 3col the value of M[i,j] will be the last that appears in the file\n#'@param def the default value in mode 3col\n#'@return matrix\nread.matrix <- function(fileName,mode=\"table\",sym=\"TRUE\",def=0){\n  switch(mode,\n         table=return(read.matrix.table(fileName,sym)),\n         col3=return(read.matrix.col3(fileName,def=def)),\n         RData=return(read.matrix.RData(fileName,sym)),\n         stop(\"Enter a valid mode\"))\n}\n\n#'Intern\n#'@keywords internal\nread.matrix.table=function(fileName,sym=\"FALSE\"){\n  mat = as.matrix(read.table(fileName))\n  if(sym){\n    #Comprovar si es simetrica primer??????\n         return((mat+t(mat))/2)\n  }\n  return(mat)\n}\n\n#'Intern\n#'@keywords internal\nread.matrix.RData=function(fileName,sym=\"FALSE\"){\n  load(fileName)\n  mat=get(ls()[ls() != \"fileName\"])\n  if(sym){\n    #Comprovar si es simetrica primer??????\n    return((mat+t(mat))/2)\n  }\n  return(mat)\n}\n\n#'Intern\n#'@keywords internal\nread.matrix.col3 = function(fileName,def=0){\n  if(class(fileName)==\"character\"){\n    MMM=read.table(fileName)\n       }\n       else{\n         MMM=fileName\n       }\n  colnames(MMM)=c(\"V1\",\"V2\",\"V3\")\n  mat2=with(MMM, sparseMatrix(i = as.numeric(V1), j=as.numeric(V2), x=V3,dimnames=list(levels(V1), levels(V2))))\n  return(mat2)\n}\n\n\n#'Read Network\n#'\n#'Read network from a file\n#'@param fileName directory of network or a data.frame\n#'@param mode tab : a file from DIP or BIOGRID of type tab or mitab;\n#'edges: a list of edges with attributes (not necessary)\n#'@param db database to select proteins of mode tab (uniprot,DIP,refseq,BIOGRID, gene)\n#'@param cols which columns must be selected with mode edges, you can use \"all\" to\n#'select all columns\n#'@param sep separator between columns in edge mode\n#'@param int.type boolean to decide if must be select the interaction type in tab mode.\nread.network = function(fileName,mode=\"tab\",db=\"uniprot\",cols = \"all\",sep=\" \",int.type=TRUE){\n  switch(mode,\n         tab=simplify(return(read.network.tab(fileName,db=db,int.type=int.type))),\n         edges = simplify(return(read.network.edges(fileName,cols,sep=sep))),\n         stop(\"No implemented yet\"))\n}\n\n#' Network tab\n#' @keywords internal\nread.network.tab = function(fileName, db=\"uniprot\", int.type=TRUE){\n  if(class(fileName)==\"character\"){\n  tab =read.table(fileName,sep=\"\\t\",row.names=NULL,stringsAsFactors=FALSE)\n  }\n  else{\n    tab=fileName\n  }\n  tab2 = tab[,c(1,2)]\n  get.int.db = function(i){\n    switch(db,\n           refseq = {x=splitrefseq(tab2[i,1])},\n           uniprot = {x=splituniprot(tab2[i,1])},\n           DIP = {x=splitDIP(tab2[i,1])},\n           BIOGRID = {x=splitBIOGRID(tab2[i,1])},\n           gene = {x=splitgene(tab2[i,1])},\n           stop(\"Enter valid database\"))\n    switch(db,\n           refseq = {y=splitrefseq(tab2[i,2])},\n           uniprot = {y=splituniprot(tab2[i,2])},\n           DIP = {y=splitDIP(tab2[i,2])},\n           BIOGRID = {y=splitBIOGRID(tab2[i,2])},\n           gene = {y=splitgene(tab2[i,2])},\n           stop(\"Enter valid database\"))\n\n    return(list(x,y))\n  }\n  tab3=list()\n  type=c()\n  for(i in 1:dim(tab2)[1]){\n    x=get.int.db(i)\n    if(!is.na(x[[1]]) && !is.na(x[[2]])){\n      tab3[[i]]=x[[1]]\n      tab3[[i+dim(tab2)[1]]]=x[[2]]\n      type[i]=tab[i,12]\n    }\n    else{\n      tab3[[i]]=NA\n      tab3[[i+dim(tab2)[1]]]=NA\n\n    }\n  }\n\n  tab3=matrix(unlist(tab3)[!is.na(tab3)],ncol=2,byrow=FALSE)\n\n  Net = graph.data.frame(tab3,directed=FALSE)\n  if(int.type){\n    type=type[!is.na(type)]\n    Net=  set.edge.attribute(Net,name=\"Interaction type\",value=type)\n  }\n  return(Net)\n}\n\n#' split refseq\n#' @keywords internal\nsplitrefseq=function(x){\n  x1 = strsplit(x,split=\"refseq:\",fixed=TRUE)[[1]]\n  if(length(x1)==2){\n    return(strsplit(x1[2],split=\"|\",fixed=TRUE)[[1]][1])\n  }\n  return(NA)\n}\n\n#' split uniprot\n#' @keywords internal\nsplituniprot=function(x){\n  x1 = strsplit(x,split=\"uniprotkb:\",fixed=TRUE)[[1]]\n  if(length(x1)==2){\n    return(x1[2])\n  }\n  return(NA)\n}\n\n#' split DIP\n#' @keywords internal\nsplitDIP=function(x){\n  x1 = strsplit(x,split=\"DIP-\",fixed=TRUE)[[1]]\n  if(length(x1)==2){\n      return(paste(\"DIP-\",strsplit(x1[2],split=\"|\",fixed=TRUE)[[1]][1],sep=\"\"))\n\n  }\n  return(NA)\n}\n\n#' split BIOGRID\n#' @keywords internal\nsplitBIOGRID = function(x){\n  x1 = strsplit(x,split=\"BIOGRID:\",fixed=TRUE)[[1]]\n  if(length(x1)==2){\n    return(x1[2])\n  }\n  return(NA)\n}\n\n#' split gene\n#' @keywords internal\nsplitgene = function(x){\n  x1 = strsplit(x,split=\"locuslink:\",fixed=TRUE)[[1]]\n  if(length(x1)==2){\n   return(strsplit(x1[2],split=\"|\",fixed=TRUE)[[1]][1])\n\n  }\n  return(NA)\n}\n\n#' Network edges\n#' @keywords internal\nread.network.edges = function(fileName,cols,sep){\n  if(class(fileName)==\"character\"){\n    tab = read.table(fileName,sep=sep,header = TRUE,stringsAsFactors=FALSE)\n\n  }\n  else{\n    tab=fileName\n  }\n  if(cols[1] ==\"all\"){\n  return(graph.data.frame(tab,directed=FALSE))\n  }\n  return(graph.data.frame(tab[,cols],directed=FALSE))\n}\n\n\n#' Compute Matrix\n#'\n#' Compute several matrices\n#' @param net1 an igraph object\n#' @param net2 an igraph object for modes \\code{BLAST} and \\code{FC} if Net2 is not NULL,\n#' computes the matrix between nodes in Net1 and Net2.\n#' @param type what matrice do you want to compute (BLAST, DSD, Distance, FC, Degree)\n#' @param mode for type \\code{BLAST} : pident or bitscore.\n#' For \\code{DSD} and \\code{Distance} distance, similarity or similarity by components.\n#' For \\code{FC} the list of ontologies\n#' @param byComp for \\code{DSD} and \\code{Distance} if the similarity or distance must be normalized\n#' by components\n#' @param database for \\code{BLAST} and \\code{FC} the database which proteins belongs.\n#' @param database2 for \\code{BLAST} and \\code{FC} the database which proteins belongs.\n#' @param normalized if the matrix will be normalized\n#' @return The matrix\ncompute.matrix = function(net1,net2=NULL, type=\"Distance\", mode = \"Similarity\", database = NULL,database2=NULL, byComp=TRUE, normalized=TRUE){\n  switch(type,\n         BLAST =return(compute.matrix.Blast(net1,net2,mode,database,database2,normalized)),\n         DSD =return(compute.matrix.DSD(net1,mode,byComp,normalized)),\n         Distance =return(compute.matrix.Distance(net1,mode,byComp,normalized)),\n         FC =return(compute.matrix.FC(net1,net2,mode)),\n         Degree = return(compute.matrix.Degree(net1,net2)),\n          stop(\"Enter a valid type\")\n  )\n}\n\n#'DSD\n#'@keywords internal\ncompute.matrix.DSD=function(net,mode=\"Similarity\",byComp=TRUE,normalized=TRUE){\n  path <- paste(system.file(package=\"PINTAS\"),\"DSDmain.py\", sep=\"/\")\n  n=length(V(net))\n  prots=V(net)$name\n  DSD = matrix(Inf,nrow=n,ncol=n)\n  dimnames(DSD)=list(prots,prots)\n  cc=decompose.graph(net)\n  for(net in cc){\n    tmp=tempfile()\n    tmp2=tempfile()\n    write.table(get.edgelist(net),quote=FALSE,file=tmp,row.names=FALSE,col.names=FALSE)\n    command = paste(\"python\",path,\"-m 1 -o\",tmp2,tmp)\n    response= system(command, intern=T)\n    table = as.matrix(read.table(paste(tmp2,\"DSD1\",sep=\".\")))\n    diam=max(table)+1\n    if(byComp){\n      if(mode==\"Similarity\"){\n        DSD[rownames(table),colnames(table)]=(max(table)+1-table)/(max(table)+1)\n      }\n      else{\n        DSD[rownames(table),colnames(table)]= table/max(table)\n      }\n    }\n    else{\n      DSD[rownames(table),colnames(table)]=table\n    }\n  }\n  mmm = max(DSD[DSD<Inf])\n  if(!byComp){\n    if(mode==\"Similarity\"){\n      DSD = (mmm+1-DSD)/(mmm+1)\n    }\n    else{\n      if(normalized){\n        DSD = DSD/mmm\n      }\n    }\n  }\n  if(mode==\"Similarity\"){\n    DSD[DSD==Inf]=0\n  }\n  DSD[DSD==-Inf]=0\n  return(DSD)\n\n  }\n\n#'Distance\n#'@keywords internal\ncompute.matrix.Distance=function(net,mode=\"Similarity\",byComp=TRUE,normalized=TRUE){\n  n=length(V(net))\n  prots=V(net)$name\n  if(!byComp){\n    dist = shortest.paths(net)\n    mmm = max(dist[dist<Inf])\n    if(mode==\"Similarity\"){\n      dist = (mmm+1-dist)/(mmm+1)\n      dist[dist==-Inf]=0\n      return(dist)\n    }\n    if(normalized){\n      dist= dist/mmm\n    }\n    return(dist)\n  }\n  if(mode==\"Similarity\"){\n    dist=matrix(0,nrow=n,ncol=n)\n  }\n  else{\n    dist=matrix(Inf,nrow=n,ncol=n)\n  }\n  dimnames(dist)=list(prots,prots)\n  cc=decompose.graph(net)\n  for(nnn in cc){\n  dist2 = shortest.paths(nnn)\n    mmm2 = max(dist2[dist2<Inf])\n    if(mode==\"Similarity\"){\n      dist2 = (mmm2+1-dist2)/(mmm2+1)\n      dist2[dist2==-Inf]=dist2[dist2==Inf]=0\n      dist[V(nnn)$name,V(nnn)$name]=dist2\n    }\n    if(normalized){\n      dist2= dist2/max(dist2[dist2<Inf])\n    }\n    dist[V(nnn)$name,V(nnn)$name]=dist2\n  }\n  return(dist)\n}\n\n#'FC\n#'@keywords internal\ncompute.matrix.FC=function(net1,net2=NULL,gos){\n  onenet=FALSE\n  if(is.null(net2)){\n    net2=net1\n    onenet=TRUE\n  }\n  prots1=V(net1)$name\n  prots2=V(net2)$name\n  if(onenet) FSim=diag(1, nrow = length(prots1),ncol=length(prots2))\n  else{\n    FSim = matrix(0, nrow = length(prots1),ncol=length(prots2))\n  }\n  dimnames(FSim)=list(prots1,prots2)\n  if(onenet){\n    for(i in 1:(length(prots1)-1)){\n      for(j in (i+1):length(prots1)){\n        fc = length(intersect(gos[[prots1[i]]],gos[[prots1[j]]]))/length(\n          union(gos[[prots1[i]]],gos[[prots1[j]]]))\n        FSim[i,j]=FSim[j,i]=fc\n      }\n    }\n\n  }\n  else{\n    for(i in 1:length(prots1)){\n      for(j in 1:length(prots2)){\n        fc = length(intersect(gos[[prots1[i]]],gos[[prots2[j]]]))/length(\n          union(gos[[prots1[i]]],gos[[prots2[j]]]))\n        FSim[i,j]=fc\n      }\n    }\n  }\n  return(FSim)\n}\n\n#'Degree\n#'@keywords internal\ncompute.matrix.Degree=function(net1,net2=NULL){\n  if(is.null(net2)){\n    net2=net1\n }\n deg = degree(net1)\n deg2 = degree(net2)\n return(matrix(unlist(lapply(deg, function(i) lapply(deg2, function(j) abs(i-j)))),nrow=length(deg), byrow=TRUE))\n\n}\n\n#'IC\n#'@keywords internal\ncomputeIC = function(net1,net2){\n  degree1 = degree(net1)\n  degree2 = degree(net2)\n  neigh1 = neighborhood(net1,order=1)\n  neigh2 = neighborhood(net2,order=1)\n  lens1 = unlist(lapply(neigh1,length))\n  lens2 = unlist(lapply(neigh2,length))\n  sums1 = unlist(lapply(neigh1,function(i) sum(1/lens1[i])))\n  sums2 = unlist(lapply(neigh2,function(i) sum(1/lens2[i])))\n  mat = matrix(0,nrow=vcount(net1),ncol=vcount(net2))\n  maxneig = max(degree1,degree2)\n  for(i in 1:vcount(net1)){\n    for(j in 1:vcount(net2)){\n      mat[i,j]=min(sums1[i],sums2[i])/maxneig\n    }\n  }\n  dimnames(mat)=list(V(net1)$name,V(net2)$name)\n  return(mat)\n}\n\n#'No funciona\n#'@keywords internal\ncompute.matrix.Blast=function(Net1,Net2,mode,database,database2,normalized){\n  tmp =tempfile()\n  buildBlast(Net1,Net2,mode,database,database2,tmp)\n  BlastM = read.matrix.table(tmp)\n  if(normalized){\n    return(BlastM/max(BlastM))\n  }\n  return(BlastM)\n}\n\n#'No funciona\n#'@keywords internal\nbuildBlast = function(Net1,Net2,mode,database,database2,tmp){\n  path <- paste(system.file(package=\"PINTAS\"),\"Blast.jar\", sep=\"/\")\n  tmp1 = tempfile()\n  write(V(Net1)$name,file=tmp1)\n  tmp2 = tempfile()\n  if(Net2==NULL){\n    tmp2=tmp1\n  }\n  else{\n    write(V(Net2)$name,file=tmp2)\n  }\n  if(database2==NULL){\n    database=database2\n  }\n  command = paste(\"java\",path,\"-prot1\",tmp1,\"-prot2\",tmp2,\"-db1\",\n                  database,\"-db2\",database2,\"-m\",mode,\"-outfmt mat -o\",tmp)\n  response= system(command, intern=T)\n\n}\n\n#'Cluster Network\n#'\n#'Compute the cluster matrix from the similarity matrix sigma, where all the nodes have more\n#'similarity than lambda and the size of cluster is less than k.\n#'\n#'@param sigma a similarity matrix\n#'@param lambda the similarity threshold\n#'@param k the size threshold\n#'@return The cluster matrix, where M[i,j] is 1 if node i belongs to the cluster of node j and\n#'0 otherwise\ncluster.network <- function(sigma, lambda=0, k=dim(sigma)[1]){\n if(is.data.frame(sigma)){\n   sigma=read.matrix.col3(sigma,def=0)\n\n }\n  n=dim(sigma)[1]\n  clustmatrix=matrix(as.numeric(c(as.matrix(sigma))>=lambda),nrow=n,byrow=TRUE)\n  sums = apply(clustmatrix,2,sum)\n  ind=which(sums>k)\n  if(length(ind)>0){\n  lapply(ind,function(i)  clustmatrix[sort(as.matrix(sigma)[i,],index.return=TRUE)$ix[1:(n-k)],i]<<-0)\n  }\n  dimnames(clustmatrix)= dimnames(sigma)\n  clustmatrix=as(clustmatrix,\"sparseMatrix\")\n  return(clustmatrix)\n\n}\n\n# #'Compute i,j\n# #'@keywords internal\n# compute.i.j = function(mat,i,j){\n#   if(is.data.table(mat)){\n#     return(mat[list(i,j)]$V3)\n#   }\n#   return(mat[i,j])\n# }\n\n#'Extract clusters\n#'\n#'Compute the subnetworks of \\code{Net} from a cluster matrix\n#'@param Net an igraph object\n#'@param ClustMat a cluster matrix (output of \\code{cluster.matrix})\n#'@return Clusters in igraph format\nextract.clusters <- function(Net, ClustMat){\n  prots=rownames(ClustMat)\n  clusts = lapply(1:dim(ClustMat)[2], function(i) induced.subgraph(Net,prots[ClustMat[,i]==1]))\n  return(clusts)\n\n}\n\n#'Display Clusters\n#'\n#'Given a cluster matrix, see \\code{cluster.network} and a network\n#'display the cluster matrix with the following colors for the position (i,j):\n#'\n#'- Yellow if the protein and protein i doesn't belongs to cluster of protein j and\n#' proteins don't interact in the network\n#'\n#'-  Black if the protein and protein i belongs to cluster of protein j but\n#' proteins don't interact in the network\n#'\n#'- Red if the protein and protein i doesn't belongs to cluster of protein j but\n#' proteins interact in the network\n#'\n#'-  Green if the protein and protein i belongs to cluster of protein j and\n#' proteins interact in the network\n#'\n#'@param clust a matrix which is the output1 of \\code{cluster.network}\n#'@param cols a list of 4 colors if you want to change the default colors\n#'@param zoom an integer to define the size of plot or NA, to plot all clusters\n#'@param type 0 = \"yellow\", 1 = \"black\", 2=\"red\", 3 = \"green\"\n#'@param col color to use with zoom\n#'@param Net an igraph object\n#'@param ... Additional plotting parameters\ndisplay.clusters <- function(clust, Net,zoom=NA, type = 1, cols=c(\"yellow\",\"black\",\"red\",\"green\"),col=cols[type+1],...){\n  clust = as.matrix(clust)\n  if(is.na(zoom)){\n  mmm =   clust+2*as.matrix(get.adjacency(Net))\n  dimnames(mmm) = list(1:dim(mmm)[1],1:dim(mmm)[2])\n # par(oma=c(1,1,1,1))\n  image2D(mmm,\n          col=cols,\n          axes=F,\n          xlab=NA,\n          ylab=NA,\n          colkey=FALSE,\n          ...)\n  axis(1,at=seq(0,1,by=1/(dim(clust)[2]-1)),\n       labels=colnames(clust),las=2,\n       pos=-1/(2*(dim(clust)[1]-1)))\n  axis(2,at=seq(0,1,by=1/(dim(clust)[1]-1)),\n       labels=rownames(clust),las=2,pos=-1/(2*(dim(clust)[2]-1)))\n  legend(x=0.2,y=1.4,legend=0:3,fill=cols,horiz=TRUE,bty=\"n\",xpd=TRUE,)\n\n}\nelse{\n  mat = clust+2*as.matrix(get.adjacency(Net))\n  k = floor(length(V(Net))/zoom)\n  conts = unlist(lapply(1:zoom,function(i) lapply(1:zoom, function(j) cont.type(mat,(i-1)*k+1,i*k,(j-1)*k+1,j*k,type)) ))\n  mat2 = matrix(conts,nrow=zoom, byrow=TRUE)\n  print(\"Min\")\n  print(min(mat2))\n  print(\"Max\")\n  print(max(mat2))\n  image2D(mat2, col = ramp.col(col=c(\"white\",col),n=k*k),\n          axes=F,\n          xlab=NA,\n          ylab=NA,\n          ...)\n\n}\n\n}\n\n#' Cont type\n#' @keywords internal\ncont.type = function(mat,init1, fin1,init2,fin2,type){\n  return(length(which(mat[init1:fin1,init2:fin2]==type)))\n}\n",
    "created" : 1447777919005.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "587954200",
    "id" : "E0CE7B95",
    "lastKnownWriteTime" : 1447784328,
    "path" : "~/PaquetPintas/AligNet/R/Analysis.R",
    "project_path" : "R/Analysis.R",
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}
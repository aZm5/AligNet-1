{
    "contents" : "#'Hungarian\n#'@keywords internal\nHungarianFinal=function(mat,maxim=TRUE){\n  nodesnet1=rownames(mat)\n  nodesnet2=colnames(mat)\n  if(dim(mat)[1]>dim(mat)[2]){\n    alin <- solve_LSAP(t(mat),maximum=maxim)\n    alin<-cbind(nodesnet1[alin],nodesnet2[seq_along(alin)])\n  }\n  else{\n    alin <- solve_LSAP(mat,maximum=maxim)\n    alin<-cbind(nodesnet1[seq_along(alin)],nodesnet2[alin])\n  }\n  return(alin)\n}\n\n\n#'Edge Correctness Score\n#'\n#' Given two networks, \\code{net1}=(\\eqn{V_1,E_1}) , \\code{net2}=(\\eqn{V_2,E_2}), and an\n#' alignment \\eqn{g:V_1 \\rightarrow V_2}, then the edge correctnees is defined as:\n#'\\deqn{\\frac{|\\{(u,v)\\in E_1 \\: : \\; (g(u),g(v))\\in E_2\\}|}{|E_1|}}\n#'@param alin  alignment, with the format of \\code{alin.local} or \\code{alin.global}\n#'@param net1  network\n#'@param net2  network\n#'@return EC score\nEC.score = function(alin,net1,net2){\n  alini= function(x,y){matrix(c(as.character(alin[x])\n                                ,as.character(alin[y])),nrow=1)}\n  E1=get.edgelist(net1)\n  if(dim(E1)[1]==0){\n    return(0)\n  }\n  eds=t(mapply(alini,E1[,1],E1[,2]))\n  nas=unique(c(which(is.na(eds[,2])),which(is.na(eds[,1]))))\n  if(length(nas)>0){\n    eds = eds[-nas,]\n  }\n  if(is.null(dim(eds))){\n    if(length(eds)==2){\n      eds = cbind(eds[1],eds[2])\n    }\n  }\n  if(dim(eds)[1]==0){ return(0)}\n  else{\n    if(dim(eds)[2]==1){ return(0)}\n  }\n  Gnet3=graph.edgelist(eds,directed=FALSE)\n  ggg4=graph.intersection(Gnet3,net2,byname=TRUE)\n  Gnet1=induced.subgraph(net1,vids=names(alin))\n  Gnet2=induced.subgraph(net2,vids=alin)\n  if(min(length(E(Gnet1)),length(E(Gnet2)))==0){\n    return(0)\n  }\n  return(length(E(ggg4))/min(length(E(Gnet1)),length(E(Gnet2))))\n\n}\n\n#'Functional Coherence Score\n#'\n#'Given an alignment \\eqn{g:V_1 \\rightarrow V_2}, and an ontologies \\eqn{gos},\n#'then the functional coherence score is defined as:\n#'\\deqn{\\frac{1}{|V_1|} \\sum_{v \\in V_1} \\frac{|gos(v) \\cap gos(g(v))|}{|gos(v)\\cup gos(g(v))|}}\n#'@param alin alignment, with the format of \\code{alin.local} or \\code{alin.global}\n#'@param gos a list of ontologies\n#'@return FC score\nFC.score = function(alin, gos ){\n  aa1=names(alin)\n  aa2=alin\n\n  fcs = unlist(lapply(1:length(aa1),function(i) length(intersect(gos[[aa1[i]]][[1]],gos[[aa2[i]]][[1]]))/\n                        length(union(gos[[aa1[i]]][[1]],gos[[aa2[i]]][[1]]))))\n  return(mean(fcs,na.rm=TRUE))\n}\n\n#'Local alignment\n#'\n#'Compute the local alignment between the networks \\code{net1} and\n#'\\code{net2} with centers \\code{p1} and \\code{p2}\n#'@param net1 network\n#'@param net2 network\n#'@param p1 center of net1\n#'@param p2 center of net2\n#'@param compute.ec compute ecscore (TRUE/FALSE)\n#'@param mat a non dissimilarity matrix\n#'@return alignment\nalign.local =  function(net1,net2,p1,p2,compute.ec=FALSE,mat=NULL){\n  mat1=compute.matrix.Degree(net1,net2)\n  if(is.null(mat)){\n    mat = mat1\n  }\n  else{\n    mat = mat[V(net1)$name,V(net2)$name]+mat1\n  }\n  dimnames(mat)=list(V(net1)$name,V(net2)$name)\n  neigh1 = neighborhood(graph=net1,order=1)\n  neigh1 = lapply(1:length(V(net1)),function(i) V(net1)$name[neigh1[[i]]])\n  names(neigh1)=V(net1)$name\n  neigh2 = neighborhood(graph=net2,order=1)\n  neigh2 = lapply(1:length(V(net2)),function(i) V(net2)$name[neigh2[[i]]])\n  names(neigh2)=V(net2)$name\n  assign=p2\n  names(assign)=c(p1)\n  completes = c()\n  incomplets = c(p1)\n  assignats = c(p2)\n  while(length(assign)<length(neigh1)){\n    q1 = incomplets[1]\n    q2 = assign[q1]\n    n1 = setdiff(neigh1[[q1]],names(assign))\n    n2 = setdiff(neigh2[[q2]],assign)\n    assign2=c()\n\n    if(length(n2)>1 && length(n1)>1){\n      mat2 = mat[n1,n2]\n      dimnames(mat2)=list(n1,n2)\n\n    }\n    else{\n      mat2=c()\n      if(length(n1)*length(n2)>0){\n        if(length(n1)==1 && length(n2)==1){\n          assign2=n2\n          names(assign2)=n1\n          assign = c(assign,assign2)\n\n        }\n        else{\n          if(length(n1)==1){\n            assign2=names(which.min(mat[n1,n2]))\n            names(assign2)=n1\n            assign = c(assign,assign2)\n          }\n          if(length(n2)==1){\n            assign2=n2\n            names(assign2)=names(which.min(mat[n1,n2]))\n            assign = c(assign,assign2)\n          }\n        }\n      }\n    }\n\n    if(!is.null(dim(mat2))){\n      if(dim(mat2)[1]>dim(mat2)[2]){\n        hung = HungarianFinal(as.matrix(t(mat2)),maxim=FALSE)\n        assign2 = hung[,1]\n        names(assign2)=hung[,2]\n        inds = sort(unlist(lapply(1:dim(hg)[1], function(i) t(mat2)[hg[i,1],hg[i,2]])),decreasing=TRUE,index.return=TRUE)$ix\n        assigns2=assigns2[inds]\n        assign = c(assign,assign2)\n\n      }\n      else{\n        hung = HungarianFinal(as.matrix(mat2),maxim=FALSE)\n        assign2 = hung[,2]\n        names(assign2)=hung[,1]\n        inds = sort(unlist(lapply(1:dim(hg)[1], function(i) t(mat2)[hg[i,1],hg[i,2]])),decreasing=TRUE,index.return=TRUE)$ix\n        assigns2=assigns2[inds]\n        assign = c(assign,assign2)\n      }\n    }\n\n    incomplets=incomplets[-1]\n    incomplets = c(incomplets,names(assign2))\n\n\n    if(length(incomplets)==0){\n      break\n    }\n  }\n  if(length(assign)==0){\n    assign=p2\n    names(assign)=p1\n  }\n  if(compute.ec){\n    return(list(align=assign,ec = EC.score(assign,net1,net2)))\n  }\n  return(list(align=assign))\n}\n\n#'alin_aux\n#'@keywords internal\nalin_aux = function(p1,mat,ll,clust1,clust2,mat2=NULL){\n  pp2 = intersect(names(which(mat[p1,]>ll)),names(clust2))\n  protsc1 = V(clust1[[p1]])$name\n  if(length(pp2)==0){\n    #   pp2 = c(names(which.max(mat[p1,])))\n    return(list())\n  }\n  return(lapply(pp2,function(p2) align.local(clust1[[p1]],clust2[[p2]],p1,p2,mat=mat2)))\n\n}\n\n#'All local alignments\n#'\n#'Compute a list of local alignments between \\code{clust1} and\n#'\\code{clust2}. The function compute all the local alignments of all pairs\n#'of clusters whose centers have a similarity greather than \\code{ll}\n#'@param clust1 a list of clusters\n#'@param clust2 a list of clusters\n#'@param mat a similarity matrix\n#'@param threshold a threshold\n#'@param cores number of cores\n#'@param dismat a disimilarity matrix to use in the local aligments\n#'@return a list of alignments\nalign.local.all = function(clust1,clust2,mat,threshold,cores=2,dismat=NULL){\n  prots1 = intersect(names(clust1),rownames(mat))\n  aligns = mclapply(prots1,function(i) alin_aux(i,mat,threshold,clust1,clust2,dismat),mc.cores=cores)\n  return(aligns)\n}\n\n\n#'Size score\n#'\n#'Compute the size score of the list of local alignments. Given an alignment\n#'\\eqn{g:V_1 \\rightarrow V_2}, the size score of \\eqn{g} is defined as \\eqn{|V_1|}\n#'@param localAligns a list of local alignments\n#'@return sizeScore a table with 3 columns, the first and second ones represents the\n#'local alignment and the third the score of alignment\nsize.score.all = function(localAligns){\n  #als = unlist(localAligns,recursive=FALSE)\n  als=localAligns\n  align.size = unlist(lapply(als,function(i) length(i)))\n  align.name1 = unlist(lapply(als,function(i) names(i)[1]))\n  align.name2 = unlist(lapply(als,function(i) i[1]))\n\n  return(cbind(align.name1,align.name2,align.size))\n}\n\n\n#'Similarity Score\n#'\n#'Compute the similarity score of the list of local alignments. Given an\n#'alignment \\eqn{g:V_1\\rightarrow V_2}, and a similarity matrix \\eqn{sim}, the\n#'similarity score of the alignment \\eqn{g} is defined as:\n#'\\deqn{\\frac{1}{|V_1|} \\sum_{v \\in V_1} sim[v,g(v)]}\n#'@param localAligns a list of local alignments\n#'@param sim a similarity matrix\n#'@return simScore a table with 3 columns, the first and second ones represents the\n#'local alignment and the third the score of alignment\nsim.score.all = function(localAligns,sim){\n  #als = unlist(localAligns,recursive=FALSE)\n  als=localAligns\n  align.sim = unlist(lapply(als,function(i) sim.score(i,sim)))\n  align.name1 = unlist(lapply(als,function(i) names(i)[1]))\n  align.name2 = unlist(lapply(als,function(i) i[1]))\n\n  return(cbind(align.name1,align.name2,align.sim))\n}\n\n#'simScore.aux\n#'@keywords internal\nsim.score=function(align,sim){\n  sco = sum(diag(sim[names(align),align]))\n  n = length(align)\n  return(sco/n)\n}\n\n#'Edges score\n#'\n#'Compute the EC.score of the list of local alignments\n#'@param localAligns, a list of local alignments\n#'@param net1 an igraph object\n#'@param net2 an igraph object\n#'@return edgesScore  a table with 3 columns, the first and second ones represents the\n#'local alignment and the third the score of alignment\nEC.score.all = function(localAligns,net1,net2){\n  #als = unlist(localAligns,recursive=FALSE)\n  als=localAligns\n  align.ec = unlist(lapply(als,function(i) EC.score(i,net1,net2)))\n  align.name = unlist(lapply(als,function(i) names(i)[1]))\n  align.name2 = unlist(lapply(als,function(i) i[1]))\n\n  return(cbind(align.name,align.name2,align.ec))\n}\n#'Select alignments\n#'\n#'Select a list of aligments that recover all the proteins, based on the\n#'list of scores\n#'@param localAligns a list of local alignments\n#'@param scores a table of scores\n#'@return selectAligns a list of local alignments\nselect.aligns = function(localAligns, scores){\n  #als = unlist(localAligns,recursive=FALSE)\n  als=localAligns\n  als2 = list()\n  protsin = 0\n  prots = c()\n  n = length(unique(scores[,1]))\n  while(protsin< n){\n\n    i = which.max(scores[,2])\n    al1 = als[[i]]\n    prots = append(prots,names(al1))\n    prots = unique(prots)\n    protsin = length(prots)\n    for(p1 in names(al1)){\n      if(p1%in%scores[,1]){\n        scores[which(scores[,1]==p1),2]=-1\n      }\n    }\n    als2 = append(als2,list(al1))\n  }\n  return(als2)\n}\n\n#'is.element2\n#'@keywords internal\nis.element2 = function(i,j){\n  return(is.element(j,i))\n}\n\n#'Compute score\n#'@keywords internal\ncompute.score = function(als2,Sim){\n  blasts = sim.score.all(als2,Sim)\n  tamanys = size.score.all(als2)\n  score = tamanys\n  score[,3]=as.numeric(score[,3])/max(as.numeric(score[,3]))\n  if(max(as.numeric(blasts[,3]))>0){\n    score[,3] = as.numeric(score[,3]) + as.numeric(blasts[,3])/max(as.numeric(blasts[,3]))\n  }\n  colnames(score)=c(\"V1\",\"V2\",\"V3\")\n  rownames(score) = NULL\n  sc3 = floor(100*as.numeric(score[,3]))\n  score = as.data.frame(score)\n  score$V3 = sc3\n\n  return(score)\n}\n\n\n\n#'Global Alignment of two Protein Interaction Network\n#'\n#'Return a global alignment, from the list of local alignments and the table\n#'of scores. The function first calculate a list of alignments with\n#'\\code{selectAligns}, then found a solution of the hypergraph mathching\n#'problem. And finally extend this alignment to a global alignment\n#'@param localAligns a list of local alignments\n#'@param Sim a similarity matrix\n#'@return Global a list of two global alignments, the first one is the\n#'solution of the hypergraph matching problem, and the second one is the\n#'extension of this alignment\nalign.global = function(localAligns,Sim){\n  global = c()\n  als = unlist(unlist(localAligns,recursive=FALSE),recursive=FALSE)\n  scores = compute.score(als, Sim)\n  Mat = with(scores, sparseMatrix(i = as.numeric(V1), j = as.numeric(V2),\n                                  x = V3, dimnames = list(levels(V1), levels(V2))))\n  globals = list()\n  Mat = as.matrix(Mat)\n  while (max(Mat) > 0) {\n    hg = HungarianFinal(Mat)\n    als2 = get.aligns(als, hg, Mat)\n    score = compute.score(als2, Sim)\n    als2 = select.aligns(als2, score[, c(1, 3)])\n    hy = hypergraph.solve(als2)\n    global = c(global, hy)\n    globals = append(globals, list(global))\n    als = aligns.update(als, global)\n    if (length(als) > 0) {\n      als = remove.global(als, global)\n      scores = compute.score(als, Sim)\n    }\n    else {\n      scores = matrix(1:3, nrow = 1, ncol = 3)[-1, ]\n    }\n    if (dim(scores)[1] > 0) {\n      Mat = with(scores, sparseMatrix(i = as.numeric(V1),\n                                      j = as.numeric(V2), x = V3, dimnames = list(levels(V1),\n                                                                                  levels(V2))))\n      Mat = as.matrix(Mat)\n    }\n    else {\n      Mat = matrix(0, nrow = 1, ncol = 1)\n    }\n  }\n  global2 = align.end(localAligns, global)\n  return(list(globals, global2))\n}\n\n#'Update aligns\n#'@keywords internal\naligns.update = function(als,global){\n  if(length(global)==0){\n    return(als)\n  }\n  prots1 = names(global)\n  prots2 = global\n  als2 = list()\n  for(al in als){\n    if(!al[1]%in%prots2){\n      if(!names(al)[1]%in%prots1){\n        als2 = append(als2,list(al))\n      }\n    }\n  }\n  return(als2)\n}\n\n#'get aligns\n#'@keywords internal\nget.aligns = function(als,hg,Mat){\n  als2 = list()\n  prots1 = hg[,1]\n  prots2 = hg[,2]\n  for(al in als){\n    if(al[1]%in%prots2){\n      i = which(al[1]==prots2)\n      if(names(al)[1]==prots1[i]){\n        if(Mat[names(al[1]),al[1]]>0){\n          als2 = append(als2,list(al))\n        }\n      }\n    }\n  }\n  return(als2)\n}\n\n#'remove global\n#'@keywords internal\nremove.global = function(als2,global){\n  for(i in 1:length(als2)){\n    als2[[i]] = als2[[i]][which(!als2[[i]]%in%global)]\n    als2[[i]]  = als2[[i]][which(!names(als2[[i]])%in%names(global))]\n  }\n  return(als2)\n}\n\n#'Solve hypergraph\n#'@keywords internal\nhypergraph.solve = function(als){\n  E2= als\n  E1 = lapply(E2,names)\n  scores = unlist(lapply(E1, length))\n  cprots1 = count(unlist(E1))\n  prots1 = cprots1[,1]\n  cprots2 = count(unlist(E2))\n  prots2 = cprots2[,1]\n  vars = length(E1)\n  constr1 = length(prots1)\n  constr2= length(prots2)\n  constr = constr1+constr2\n  lprec = make.lp(constr,vars)\n  constr11= lapply(prots1, function(i) as.numeric(unlist(lapply(E1,is.element2,i))))\n  constr22= lapply(prots2, function(i) as.numeric(unlist(lapply(E2,is.element2,i))))\n\n  ##Set constraints\n  fcon1 = function(i){\n    s = sum(constr11[[i]])\n    if(s>0){\n      set.row(lprec,i,xt=rep(1,s),indices=which(constr11[[i]]==1))\n    }\n  }\n\n  aa=lapply(1:constr1, fcon1)\n  fcon2 = function(i){\n    s= sum(constr22[[i]])\n    if(s>0){\n      set.row(lprec,i+constr1,xt=rep(1,s),indices=which(constr22[[i]]==1))\n    }\n  }\n\n  bb= lapply(1:constr2, fcon2)\n\n  set.objfn(lprec,unlist(scores))\n  set.constr.type(lprec,c(rep(\"<=\",constr)))\n  set.rhs(lprec,c(rep(1,constr)))\n  set.bounds(lprec,lower=rep(0,vars),upper=rep(1,vars),columns=1:vars)\n\n  set.type(lprec,1:vars,\"binary\")\n  break.value = min(length(prots1),length(prots2))\n  lp.control(lprec,sense=\"max\",verbose=\"neutral\",break.at.first=TRUE)\n  solve(lprec)\n  sols=which(get.variables(lprec)>0)\n\n  getprots = function(i,E2){\n    matrix(c(names(E2[[i]]),E2[[i]]),ncol=2)\n  }\n  mmm=getprots(sols[[1]],E2)\n  nsol = length(sols)\n  if(nsol>1){\n    for(i in 2:nsol){\n      mmm=rbind(mmm,getprots(sols[[i]],E2))\n    }\n  }\n\n  global = mmm[,2]\n  names(global)=mmm[,1]\n  return(global)\n}\n\n\n#'Update Matrix\n#'@keywords internal\nmatrix.update = function(mat,global){\n  mat2 = mat\n  rows.delete=which(rownames(mat2)%in%names(global))\n  cols.delete=which(colnames(mat2)%in%global)\n  mat2=mat2[-rows.delete,]\n  if(is.null(dim(mat2))){\n    if(length(mat2)>0){\n      mat2 = matrix(mat2,nrow=1)\n      rownames(mat2)=setdiff(rownames(mat),names(global))\n      colnames(mat2)=colnames(mat)\n      mat3=mat2[,-cols.delete]\n      mat3 = matrix(mat3,nrow=1)\n      colnames(mat3)=setdiff(colnames(mat2),global)\n      rownames(mat3)=rownames(mat2)\n      return(mat3)\n\n    }\n    else{\n      return(matrix(0, nrow=1,ncol=1))\n    }\n  }\n  mat3=mat2[,-cols.delete]\n  if(is.null(dim(mat3))){\n    if(length(mat3)>0){\n      mat3 = matrix(mat3,ncol=1)\n      colnames(mat3)=setdiff(colnames(mat2),global)\n      rownames(mat3)=rownames(mat2)\n    }\n    else{\n      mat3 = matrix(0, nrow=1,ncol=1)\n    }\n  }\n  return(mat3)\n}\n\n#'End alignment\n#'@keywords internal\nalign.end = function(localAligns,global){\n  als=unlist(unlist(localAligns,recursive=FALSE),recursive=FALSE)\n  mmm = cbind(names(global),global)\n  E2= lapply(seq(1,length(als),2), function(i) als[i][[1]])\n  E1 = lapply(E2,names)\n\n  prots1 = unique(unlist(E1))\n\n  rest2= unlist(E2)\n  rest1 = names(rest2)\n  restm=count(matrix(c(rest1,rest2),byrow=FALSE,ncol=2))\n  restm = data.frame(restm,row.names=1:dim(restm)[1])\n  colnames(restm)=c(\"V1\",\"V2\",\"V3\")\n  mat2=with(restm, sparseMatrix(i = as.numeric(V1), j=as.numeric(V2), x=V3,dimnames=list(levels(V1), levels(V2))))\n  mat2[mat2>0]=1\n\n  for(i in 1:dim(mmm)[1]){\n    if(is.element(mmm[i,1],rownames(mat2))){\n      mat2[mmm[i,1],]=-1\n    }\n    if(is.element(mmm[i,2],colnames(mat2))){\n      mat2[,mmm[i,2]]=-1\n    }\n  }\n  mat2 = as.matrix(mat2)+1\n  hg=HungarianFinal(as.matrix(mat2))\n\n\n  for(i in 1:dim(hg)[1]){\n    if(mat2[hg[i,1],hg[i,2]]>0){\n      mmm=rbind(mmm,hg[i,])\n    }\n  }\n\n  global2 = mmm[,2]\n  names(global2)=mmm[,1]\n  return(global2)\n}\n\n#'Plot the alignment\n#'@param net1 an igraph object\n#'@param net2 an igrpah object\n#'@param global an alignment\n#'@param k1 the width of the new edges of the alignment\n#'@param k2 the width of the old edges\n#'@param edge.curved Specifies whether to draw curved\n#'edges, or not. This can be a logical or a numeric vector or scalar.\n#'@param ... further arguments to be passed to igraph plotting\nalign.plot = function(net1,net2,global,k1,k2,edge.curved=0.5,...){\n  coms1 = fastgreedy.community(net1)\n  coms2 = fastgreedy.community(net2)\n  newedges = cbind(names(global),global)\n  net3 = graph.data.frame(newedges,directed=FALSE)\n  net4 = graph.union(net1,net2)\n  net5=graph.union(net3,net4)\n  num.eds = ecount(net5)\n  eds = get.edgelist(net5)\n  E(net5)$weight=k1\n  E(net5)$edge.curved=0\n  eds1 = get.edgelist(net4)\n  ids = get.edge.ids(net5,t(eds1),FALSE)\n\n  net5 = set.edge.attribute(net5,name=\"weight\",index=ids,k2)\n  net5 = set.edge.attribute(net5,name=\"edge.curved\",index=ids,edge.curved)\n\n  inds1=sort(coms1$membership,index.return=TRUE)\n\n  lay1 = 1:vcount(net1)\n  lay2 = rep(0,vcount(net2))\n  lay12 = lay1[inds1$ix]\n  names(lay12)=V(net1)$name\n  lay = cbind(10,rep(0,vcount(net5)))\n  for(p1 in V(net1)$name){\n    i1 = which(V(net5)$name==p1)\n    p2 = global[p1]\n    i2 = which(V(net5)$name==p2)\n    lay[i1,]=c(0,lay12[p1])\n    lay[i2,]=c(10,lay12[p1])\n  }\n  print(\"plot\")\n  print(net5)\n  plot(net5,layout=layout.norm(lay),rescale=TRUE, edge.curved=E(net5)$edge.curved,edge.width =E(net5)$weight,...)\n}\n\n#'Search alignments\n#' Search alignments in als from p1 to p2\n#' @param als a list of local alignments\n#' @param p1 a protein\n#' @param p2 a protein\n#' @return list of alignments that includes p1 and p2\nsearch.aligns = function(als,p1,p2){\n  clustp1 = c()\n  clustp2 = c()\n  for(al in als){\n    if(p1==names(al)[1]){\n      if(al[p1]==p2){\n        clustp1 = names(al)\n        clustp2 = als\n      }\n    }\n  }\n  als2 = list()\n  for(al in als){\n    al.aux = al[intersect(names(al),clustp1)]\n    if(length(al.aux)>0){\n      als2 = append(als2,list(al.aux))\n    }\n  }\n  return(als2)\n\n}\n\n#'Local alignment plot\n#'plot a local alignment and all the local alignments that\n#'intersect with him\n#'@param localAligns a list of local alignments\n#'@param global an alignment\n#'@param p1 the center of cluster1\n#'@param p2 the center of cluster2\n#'@param net1 the first network\n#'@param net2 the second network\n#'@param ... further arguments to be passed to igraph plotting\nalign.local.plot = function(localAligns,global,p1,p2,net1,net2,...){\n  als = unlist(unlist(localAligns,recursive=FALSE),recursive=FALSE)\n  als = search.aligns(als,p1,p2)\n  alp1p2=NULL\n  for(al in als){\n    if(p1==names(al)[1]){\n      if(al[p1]==p2){\n        alp1p2 = al\n      }\n    }\n  }\n  if(is.null(alp1p2)){\n    print(\"Local alignment not found\")\n    return(NULL)\n  }\n  alini= function(x,y){matrix(c(as.character(alp1p2[x])\n                                ,as.character(alp1p2[y])),nrow=1)}\n  E1=get.edgelist(net1)\n  if(dim(E1)[1]==0){\n    return(0)\n  }\n  eds=t(mapply(alini,E1[,1],E1[,2]))\n  nas=unique(c(which(is.na(eds[,2])),which(is.na(eds[,1]))))\n  if(length(nas)>0){\n    eds = eds[-nas,]\n    eds1 = E1[-nas,]\n  }\n  if(is.null(dim(eds))){\n    if(length(eds)==2){\n      eds = cbind(eds[1],eds[2])\n      eds1 = cbind(eds1[1],eds1[2])\n    }\n  }\n  eds = rbind(eds,eds1)\n  Gnet3=graph.edgelist(eds,directed=FALSE)\n\n  cols = rainbow(length(als))\n  new.edges = cbind(names(alp1p2),alp1p2)\n  net3 = graph.data.frame(new.edges,directed=FALSE)\n\n  nets = list(net3)\n  for(al in als){\n    new.edges = cbind(names(al),al)\n    net3 = graph.data.frame(new.edges,directed=FALSE)\n    nets = append(nets,list(net3))\n  }\n  net12 = induced.subgraph(net1,vids=unique(unlist(lapply(als,names))))\n  net22 = induced.subgraph(net2,vids=unique(unlist(als)))\n  net4 = graph.union(net12,net22)\n  net5=net4\n  for(i in 1:length(nets)){\n    net5 = graph.union(net5,nets[[i]])\n  }\n  num.eds = ecount(net5)\n  eds = get.edgelist(net5)\n  newedges = cbind(names(global),global)\n  net3 = graph.data.frame(newedges,directed=FALSE)\n  net3 = induced.subgraph(net3, vids =intersect(V(net3)$name,V(net5)$name))\n  E(net5)$color=\"black\"\n  E(net5)$lty = 3\n  E(net5)$width = 0.5\n  E(net5)$edge.curved = 1\n  ids=c()\n  eds1 = get.edgelist(nets[[1]])\n  ids2 = get.edge.ids(net5,t(eds1),FALSE)\n  ids2 = setdiff(ids2,ids)\n  net5 = set.edge.attribute(net5,name=\"color\",index=ids2,cols[1])\n  net5 = set.edge.attribute(net5,name=\"edge.curved\",index=ids2,0)\n  net5 = set.edge.attribute(net5,name=\"lty\",index=ids2,2)\n\n  ids = c(ids,ids2)\n\n  for(i in 2:length(nets)){\n    eds1 = get.edgelist(nets[[i]])\n    ids2 = get.edge.ids(net5,t(eds1),FALSE)\n    ids2 = setdiff(ids2,ids)\n    net5 = set.edge.attribute(net5,name=\"color\",index=ids2,cols[i])\n    net5 = set.edge.attribute(net5,name=\"edge.curved\",index=ids2,0)\n    ids = c(ids,ids2)\n  }\n  eds1 = get.edgelist(net3)\n  ids = get.edge.ids(net5,t(eds1),FALSE)\n\n  net5 = set.edge.attribute(net5,name=\"lty\",index=ids,1)\n  net5 = set.edge.attribute(net5,name=\"edge.curved\",index=ids,0)\n  net5 = set.edge.attribute(net5,name=\"width\",index=ids,1)\n\n  eds1 = get.edgelist(Gnet3)\n  ids = get.edge.ids(net5,t(eds1),FALSE)\n  net5 = set.edge.attribute(net5,name=\"lty\",index=ids,1)\n  net5 = set.edge.attribute(net5,name=\"width\",index=ids,1)\n  net5 = set.edge.attribute(net5,name=\"color\",index=ids,cols[1])\n\n  eds1 = get.edgelist(net22)\n  ids = get.edge.ids(net5,t(eds1),FALSE)\n  net5 = set.edge.attribute(net5,name=\"edge.curved\",index=ids,-1)\n  net5 = induced.subgraph(net5,vids=union(alp1p2,names(alp1p2)))\n  lay = cbind(10,rep(0,vcount(net5)))\n  cont1 = 1\n  cont2 = 1\n  for(i in 1:vcount(net5)){\n    p = V(net5)$name[i]\n    if(is.element(p,V(net12)$name)){\n      lay[i,]=c(0,cont1)\n      cont1 = cont1+1\n    }\n    else{\n      lay[i,]=c(10,cont2)\n      cont2 = cont2+1\n\n    }\n  }\n  e1 = ecount(net5)\n  v1 = vcount(net5)\n  print(paste(\"plotting a graph with \",as.character(v1),\n              \" vertices and \",e1,\" edges\",sep=\"\"))\n  net5 = set.vertex.attribute(net5,\"pos\",index=1:vcount(net12),value=1)\n  net5 = set.vertex.attribute(net5,\"pos\",index=(vcount(net12)+1):(vcount(net22)+vcount(net12)),value=-1)\n\n  plot(net5,layout=layout.norm(lay),rescale=TRUE, vertex.label.dist=V(net5)$pos,vertex.label.degree=pi,edge.curved=E(net5)$edge.curved,...)\n}\n",
    "created" : 1447779191123.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3436359962",
    "id" : "3F833250",
    "lastKnownWriteTime" : 1448043020,
    "path" : "~/AligNet/AligNet/R/Alin.R",
    "project_path" : "R/Alin.R",
    "properties" : {
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "type" : "r_source"
}
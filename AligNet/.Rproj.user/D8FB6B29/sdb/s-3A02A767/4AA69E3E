{
    "contents" : "---\ntitle: \"How to use the package PINTAS\"\nauthor: \"Adrià Alcalá\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{Vignette Title}\n  %\\VignetteEngine{knitr::rmarkdown}\n  \\usepackage[utf8]{inputenc}\n---\n\nHow to use package PINTAS\n=============================================================\n\n```{r ,echo=FALSE, results='hide'}\nlibrary(knitr)\n\n```\n\n```{r ,warning=FALSE}\nlibrary(AligNet)\n```\n\n\nFirst we have to build the networks. We can build them using the function *read.network*. For example, from a list of protein interactions.\n```{r ,warning=FALSE}\nedges1 = matrix(c(\n  \"85962.HP0109\", \"85962.HP0136\",\n\"85962.HP0109\", \"85962.HP0137\",\n\"85962.HP0136\", \"85962.HP0247\",\n\"85962.HP0136\", \"85962.HP0303\",\n\"85962.HP0137\", \"85962.HP0247\",\n\"85962.HP0137\", \"85962.HP0853\",\n\"85962.HP0247\", \"85962.HP1316\"\n), ncol=2, byrow=TRUE)\nhpy <- read.network(edges1, mode=\"edges\")\n\nplot(hpy)\n```\n\n```{r ,warning=FALSE}\nedges2= matrix(c(\n\"DBP2_YEAST\", \"RL2A_YEAST\",\n\"HAS1_YEAST\", \"MAK5_YEAST\",\n\"NOP10_YEAST\", \"DBP2_YEAST\",\n\"NOP10_YEAST\", \"HAS1_YEAST\",\n\"NOP10_YEAST\", \"MAK5_YEAST\",\n\"NOP10_YEAST\", \"RL2A_YEAST\",\n\"TSA1_YEAST\", \"HSP7F_YEAST\",\n\"TSA1_YEAST\", \"TSA2_YEAST\"\n), ncol=2, byrow=TRUE)\nsce <- read.network(edges2,mode=\"edges\")\nplot(sce)\n```\n\n\nNow we need a similarity matrix, you can use the function *read.matrix* if you want to read the matrix from a file, or \nyou can compute it using the function *compute.matrix*. In \nthis case we load the data *Sim1* and *Sim2*, which are included in the package, and compute a distance similarity matrix, with \nthe function *compute.matrix*.\n```{r ,warning=FALSE}\n\ndata(Sim1)\ndata(Sim2)\nDis1 = compute.matrix(net1=hpy)\nDis2 = compute.matrix(net1=sce)\n\nSim1 = (Sim1+Dis1)/2\nSim2 = (Sim2+Dis2)/2\n```\n\n\nWhen we have the networks and the similarity matrices, we can compute the clusters with the functions *cluster.network* and *extract.clusters*, and then visualize the clusters with *display.clusters*.\n\n\n```{r ,fig.height=15,warning=FALSE}\n\nclust1 = cluster.network(sigma=Sim1,lambda=0.2,k=5)\n\nclusters1 = extract.clusters(Net=hpy,ClustMat=clust1)\nnames(clusters1)=colnames(Sim1)\nprint(names(clusters1))\n\nfor(i in 1:length(clusters1)){\n  print(names(clusters1)[i])\n  plot(clusters1[[i]])\n}\n\n```\n\n```{r ,fig.align='center',fig.height=10,fig.width=10,out.width=600,out.height=600}\npar(oma=c(3,3,4,3))\ndisplay.clusters(clust=clust1,Net=hpy,main=\"\")\ncols=c(\"yellow\",\"black\",\"red\",\"green\")\n legend(x=0,y=1.25,legend=0:3,fill=cols,horiz=TRUE,bty=\"n\",xpd=TRUE,cex=3)\n\n```\n\n\n```{r ,fig.height=15}\n\nclust2 = cluster.network(sigma=Sim2,lambda=0.2,k=5)\n\nclusters2 = extract.clusters(Net=sce,ClustMat=clust2)\nnames(clusters2)=colnames(Sim2)\n \n\nfor(i in 1:length(clusters2)){\n  print(names(clusters2)[i])\n  plot(clusters2[[i]])\n}\n\n```\n\n```{r ,fig.align='center',fig.height=10,fig.width=10,out.width=600,out.height=600}\npar(oma=c(3,3,4,3))\ndisplay.clusters(clust=clust2,Net=sce,main=\"\")\ncols=c(\"yellow\",\"black\",\"red\",\"green\")\n legend(x=0,y=1.25,legend=0:3,fill=cols,horiz=TRUE,bty=\"n\",xpd=TRUE,cex=3)\n\n```\n\nOnce we have the clusters, we can compute the local alignments using *align.local.all*. We can use a dissimilarity matrices to compute the local alignments.\n\n```{r ,warning=FALSE, results='asis'}\ndata(Sim)\nlocalAligns = align.local.all(clust1=clusters1,clust2=clusters2,mat=Sim,threshold=0)\nlocalAligns2 = align.local.all(clust1=clusters1,clust2=clusters2,mat=Sim,threshold=0,cores=1,dismat=1-Sim)\n\n```\n\nFinally, using the local alignments, we can compute the global alignment, using *align.global*.\n```{r ,warning=FALSE,message=FALSE}\n# scores = size.score.all(localAligns=localAligns)\n# scores2 = sim.score.all(localAligns=localAligns,sim=Sim)\n# scores[,2] = as.numeric(scores[,2])/5+as.numeric(scores2[,2])\n\nalinGlobal = align.global(localAligns=localAligns,Sim=Sim)\nalinGlobal2 = align.global(localAligns=localAligns2,Sim=Sim)\n\n```\n\n\nTo compute the edge correctness score of the global alignment, we use the function *EC.score*.\n```{r ,warning=FALSE}\nfor(glob in alinGlobal[[1]]){\nprint(EC.score(alin=glob,net1=hpy,net2=sce))\n}\nfor(glob in alinGlobal2[[1]]){\nprint(EC.score(alin=glob,net1=hpy,net2=sce))\n}\n\nEC.score(alin=alinGlobal[[2]],net1=hpy,net2=sce)\nEC.score(alin=alinGlobal2[[2]],net1=hpy,net2=sce)\n\n```\n\nTo compute the functional coherence score of the global alignment, we use the function *FC.score*.\n```{r }\n\n```\n\nTo visualize the global alignment, we can plot all the alignment with *align.plot*, or visualize only one local alignment using *align.local.plot*. The first one is useful when we have small networks, and the second one for large networks.\n\n```{r ,warning=FALSE,fig.align='center'}\nalign.plot(net1=hpy,net2=sce,global=alinGlobal2[[2]],k1=1,k2=1,edge.curved=0.5,vertex.size=5)\n```\n\n\n```{r ,warning=FALSE,fig.align='center'}\npar(oma=c(1,2,1,2))\np1 = \"85962.HP0303\"\np2 = \"RL2A_YEAST\"\nalign.local.plot(localAligns=localAligns,global=alinGlobal2[[2]],p1=p1,p2=p2,net1=hpy,net2=sce)\n```\n\n```{r ,warning=FALSE,fig.align='center'}\npar(oma=c(1,2,1,2))\n\np1 = \"85962.HP1316\"\np2 = \"HAS1_YEAST\"\nalign.local.plot(localAligns=localAligns,global=alinGlobal[[2]],p1=p1,p2=p2,net1=hpy,net2=sce)\n```\n",
    "created" : 1447491213767.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3012576599",
    "id" : "4AA69E3E",
    "lastKnownWriteTime" : 1447778281,
    "path" : "~/PaquetPintas/AligNet/vignettes/HowTo.Rmd",
    "project_path" : "vignettes/HowTo.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_markdown"
}